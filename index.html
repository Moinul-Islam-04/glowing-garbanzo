<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Posture Coach</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #2c3e50; color: #ecf0f1; margin: 0; padding-top: 20px;}
        h1 { margin-bottom: 10px; }
        #container { position: relative; width: 640px; height: 480px; }
        #video-feed, #canvas-overlay { position: absolute; top: 0; left: 0; border-radius: 8px; }
        #feedback-box { margin-top: 500px; font-size: 1.8em; font-weight: bold; padding: 15px 25px; border-radius: 8px; background: #34495e; min-height: 50px; display: flex; align-items: center; justify-content: center; text-align: center;}
    </style>
</head>
<body>
    <h1>AI Posture Coach (Side View)</h1>
    <div id="container">
        <video id="video-feed" width="640" height="480" autoplay playsinline style="transform: scaleX(-1);"></video>
        <canvas id="canvas-overlay" width="640" height="480"></canvas>
    </div>
    <div id="feedback-box">Connecting...</div>

    <script>
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('canvas-overlay');
        const ctx = canvas.getContext('2d');
        const feedbackBox = document.getElementById('feedback-box');
        
        const socket = new WebSocket(`ws://${window.location.host}/ws/posture`);

        socket.onopen = () => {
            console.log("WebSocket connected!");
            feedbackBox.textContent = "Stand by for analysis...";
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    video.srcObject = stream;
                    setInterval(sendFrame, 200);
                })
                .catch(err => {
                    console.error("Error accessing webcam:", err);
                    feedbackBox.textContent = "Error: Could not access webcam.";
                });
        };

        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            feedbackBox.textContent = data.feedback;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSkeleton(data.keypoints);
        };

        socket.onclose = (event) => {
            console.log("WebSocket disconnected.", event.reason);
            feedbackBox.textContent = "Connection Lost.";
        };

        socket.onerror = (error) => {
            console.error("WebSocket Error:", error);
            feedbackBox.textContent = "Connection Error.";
        };

        function sendFrame() {
            if (socket.readyState === WebSocket.OPEN && video.readyState === 4) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.translate(tempCanvas.width, 0);
                tempCtx.scale(-1, 1);
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

                const dataURL = tempCanvas.toDataURL('image/jpeg', 0.8);
                socket.send(dataURL);
            }
        }

        // --- UPDATED DRAW SKELETON LOGIC ---
        function drawSkeleton(keypoints) {
            if (!keypoints || Object.keys(keypoints).length === 0) return;

            // Define the connections for a side-view skeleton
            const connections = [
                ['EAR', 'SHOULDER'],
                ['SHOULDER', 'HIP'],
                ['HIP', 'KNEE']
            ];

            ctx.lineWidth = 5;
            ctx.strokeStyle = '#3498db'; // Blue for lines

            // Draw connections
            connections.forEach(([p1, p2]) => {
                if (keypoints[p1] && keypoints[p2]) {
                    ctx.beginPath();
                    ctx.moveTo(keypoints[p1][0], keypoints[p1][1]);
                    ctx.lineTo(keypoints[p2][0], keypoints[p2][1]);
                    ctx.stroke();
                }
            });

            ctx.fillStyle = '#e74c3c'; // Red for points
            
            // Draw keypoints
            for (const key in keypoints) {
                const [x, y] = keypoints[key];
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    </script>
</body>
</html>